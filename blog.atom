<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://tcha.org/</id>
  <title>tcha.org Blog</title>
  <updated>2013-12-09T14:30:00Z</updated>
  <link rel="alternate" href="http://tcha.org/"/>
  <link rel="self" href="http://tcha.org/blog.atom"/>
  <author>
    <name>Yuya Nishihara</name>
    <uri>http://tcha.org/about/</uri>
  </author>
  <entry>
    <id>tag:tcha.org,2013-12-09:/blog/2013/12/09/hg-python/</id>
    <title type="html">hg.exe を Python インタプリタにする - Mercurial Advent Calendar 2013</title>
    <published>2013-12-09T14:30:00Z</published>
    <updated>2013-12-09T14:30:00Z</updated>
    <link rel="alternate" href="http://tcha.org/blog/2013/12/09/hg-python/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://connpass.com/event/3950/"&gt;Mercurial Advent Calendar 2013&lt;/a&gt;
の 9 日目です。&lt;/p&gt;

&lt;p&gt;プログラムのビルドでちょっとしたテキスト処理をしたいことはよくあると思います。
例えば、ビルド日時やリビジョン番号、その日の天気や気分を埋め込みたいとか。&lt;br/&gt;
そんな時、 Unix であれば &lt;code&gt;sed&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;perl&lt;/code&gt; など道具はいくらでもありますが、
Windows が絡むと残念な気持ちになりますね。&lt;/p&gt;

&lt;p&gt;さて、ここでもし仮に Mercurial でソースコードを管理しているのであれば、
&lt;code&gt;hg.exe&lt;/code&gt; を使えるんじゃないでしょうか?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import sys
from mercurial import cmdutil, commands

commands.norepo += ' python'
cmdtable = {}
command = cmdutil.command(cmdtable)

@command('python',
    [('c', 'code', '', 'program passed in as string')],
    '[-c cmd | file] [arg] ...')
def python(ui, *pats, **opts):
    sys.argv = list(pats)
    ns = {'__name__': '__main__'}
    if opts['code']:
        sys.argv.insert(0, '-c')
        exec opts['code'] in ns
    elif pats:
        execfile(pats[0], ns)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このエクステンションは &lt;code&gt;hg python&lt;/code&gt; コマンドを提供します。
インストールのために稟議は不要です。&lt;/p&gt;

&lt;p&gt;使い方:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# file の SHA-1 ハッシュを生成
hg python -c "import hashlib, sys; print hashlib.sha1(sys.stdin.read()).hexdigest()" &amp;lt; file
# ファイルを選択
hg python -c "from PyQt4.QtGui import *; a = QApplication([]); print QFileDialog.getOpenFileName()"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Makefile には &lt;code&gt;PYTHON = hg python --config extensions.python=path/to/python.py&lt;/code&gt;
と定義しておけばいいでしょう。 GNU Make が使えるなら、すでに Unix
ライクな環境が整ってるかもしれませんけど。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:tcha.org,2012-12-19:/blog/2012/12/19/thgitaraise/</id>
    <title type="html">TortoiseHg のエラーを出そう - TortoiseHg Advent Calendar 2012</title>
    <published>2012-12-19T14:20:00Z</published>
    <updated>2012-12-19T14:20:00Z</updated>
    <link rel="alternate" href="http://tcha.org/blog/2012/12/19/thgitaraise/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://connpass.com/event/1504/"&gt;TortoiseHg Advent Calendar 2012&lt;/a&gt;
の 19 日目です。&lt;/p&gt;

&lt;p&gt;例外をちょっとだけ楽しくする話をします。&lt;/p&gt;

&lt;p&gt;何も言わずに下のコードを &lt;a href="http://qiita.com/items/5022fe71db024b5459ff"&gt;itarize エクステンション&lt;/a&gt;
に貼ってみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def uisetup(ui):
    if not os.path.basename(sys.argv[0]).startswith('thg'):
        # TortoiseHg以外から読み込まれた場合は何もしない
        return

    ...

    # AnnotateViewを装飾
    from tortoisehg.hgqt.fileview import AnnotateView
    Itarate(AnnotateView)

    # -- ここから --
    from tortoisehg.hgqt import bugreport
    # 念のためサブクラス化
    class BugReportTextBrowser(bugreport.QTextBrowser):
        pass
    bugreport.QTextBrowser = BugReportTextBrowser
    Itarate(BugReportTextBrowser)
    # -- ここまで --
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ほら、このとおり。&lt;/p&gt;

&lt;p&gt;&lt;img src="/blog/2012/assets/thg-exc.jpg" alt=""&gt;&lt;/p&gt;

&lt;p&gt;例外を見るのが楽しくなりますね!&lt;/p&gt;

&lt;p&gt;けれど、エラーが起きた時しか表示されなくて残念です。
せっかくなのでいつでもウィンドウを開けるようにしましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    from mercurial import extensions
    from tortoisehg.hgqt import workbench
    def itaraise():
        raise Exception('hello')

    def wbrun(orig, ui, *pats, **opts):
        w = orig(ui, *pats, **opts)
        if not isinstance(w, workbench.Workbench):
            return w
        a = QtGui.QAction(u'エラーを起こす', w.menuHelp)
        a.setShortcut('F1')
        a.triggered.connect(itaraise)
        w.menuHelp.insertAction(w.menuHelp.actions()[0], a)
        return w

    extensions.wrapfunction(workbench, 'run', wbrun)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;じゃん。&lt;/p&gt;

&lt;p&gt;&lt;img src="/blog/2012/assets/thg-excmenu.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;F1 キーを押すだけでエラーが起きるようになりました。&lt;/p&gt;

&lt;p&gt;素晴らしいエクステンションをありがとうございます! &gt; @wonderful_panda さん&lt;/p&gt;

&lt;p&gt;それでは、良いお年を。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:tcha.org,2012-12-18:/blog/2012/12/18/hgwebauth/</id>
    <title type="html">hgweb にユーザー認証させる - Mercurial Advent Calendar 2012</title>
    <published>2012-12-18T14:00:00Z</published>
    <updated>2012-12-18T14:00:00Z</updated>
    <link rel="alternate" href="http://tcha.org/blog/2012/12/18/hgwebauth/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://connpass.com/event/1431/"&gt;Mercurial Advent Calendar 2012&lt;/a&gt;
の 18 日目は、 hgweb とユーザー認証の話をします。&lt;/p&gt;

&lt;p&gt;とその前に、 LDAP の bind で認証するコードが &lt;a href="https://gist.github.com/4104596"&gt;https://gist.github.com/4104596&lt;/a&gt;
にあります。こんな記事を見るよりコードを読んだほうが早いですよ。&lt;/p&gt;

&lt;h2&gt;認証レイヤー&lt;/h2&gt;

&lt;p&gt;HTTP で Mercurial リポジトリを公開する場合、ユーザー認証を挟む場所が 2 つあります。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Web サーバー &amp;mdash; Apache の &lt;code&gt;mod_auth_basic&lt;/code&gt; や nginx の &lt;code&gt;auth_basic&lt;/code&gt; を使う。&lt;/li&gt;
&lt;li&gt;WSGI &amp;mdash; &lt;code&gt;application(environ, start_response)&lt;/code&gt; 関数で処理する。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;簡単なのは 1. です。
ですから、もちろん 2. を使います。&lt;/p&gt;

&lt;h2&gt;テストしやすくする&lt;/h2&gt;

&lt;p&gt;コードを書く前に、まず &lt;code&gt;hgweb_wsgi.py&lt;/code&gt; をテストしやすくしましょう。&lt;/p&gt;

&lt;p&gt;すでに &lt;a href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; はインストールされていることと思いますので、
Flask と一緒にインストールされた &lt;a href="http://werkzeug.pocoo.org/"&gt;Werkzeug&lt;/a&gt;
を使ってみます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/env python
from mercurial import hgweb
application = hgweb.hgwebdir('hgweb.config')

if __name__ == '__main__':
    from werkzeug import serving
    serving.run_simple('localhost', 8000, application,
                       use_debugger=True, use_reloader=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;これだけです。
&lt;code&gt;hgweb_wsgi.py&lt;/code&gt; を直接実行できて、例外でデバッガが起動するようになりました。&lt;/p&gt;

&lt;h2&gt;401 Unauthorized をフックする&lt;/h2&gt;

&lt;p&gt;クライアントへ認証を要求するには、 &lt;code&gt;401 Unauthorized&lt;/code&gt; レスポンスに &lt;code&gt;WWW-Authenticate&lt;/code&gt;
をのせる必要があります。
hgweb は認証が必要な場面で &lt;code&gt;401&lt;/code&gt; を返しますが、
&lt;code&gt;WWW-Authenticate&lt;/code&gt; ヘッダがついていません。 hgweb が認証の手段を知らないためです。&lt;/p&gt;

&lt;p&gt;&lt;a href="https://wsgi.readthedocs.org/en/latest/specifications/simple_authentication.html"&gt;A very basic description of authentication opportunities in WSGI&lt;/a&gt;
を参考にレスポンスヘッダをのせます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hgapp = hgweb.hgwebdir('hgweb.config')

def application(environ, start_response):
    def wrapped_start_response(status, headers, exc_info=None):
        if status.startswith('401'):
            realm = 'Mercurial Repository'
            headers.append(('WWW-Authenticate', 'Basic realm="%s"' % realm))
        return start_response(status, headers, exc_info)

    return hgapp(environ, wrapped_start_response)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;応答をみる&lt;/h2&gt;

&lt;p&gt;Basic 認証要求に対して、クライアントは &lt;code&gt;HTTP_AUTHORIZATION&lt;/code&gt; ヘッダで応答します。
ここでやるべきは、認証データを検証して &lt;code&gt;REMOTE_USER&lt;/code&gt; を渡すことです。
hgweb が &lt;code&gt;REMOTE_USER&lt;/code&gt; をもとに操作を「認可」します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from werkzeug import http

def check_auth(username, password):
    return {'hoge': 'fuga'}.get(username) == password

def application(environ, start_response):
    auth = http.parse_authorization_header(environ.pop('HTTP_AUTHORIZATION', None))
    if auth and check_auth(auth.username, auth.password):
        environ['REMOTE_USER'] = auth.username
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは、 &lt;code&gt;check_auth()&lt;/code&gt; を真面目に実装するだけですね。&lt;/p&gt;

&lt;h2&gt;最後に&lt;/h2&gt;

&lt;p&gt;認証が必要かどうかを hgweb が判断してくれるので楽です。
Apache の &lt;code&gt;mod_auth_basic&lt;/code&gt; を使うと、そうは行きませんね。&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:tcha.org,2012-12-16:/blog/2012/12/15/paranoid/</id>
    <title type="html">TortoiseHg を疑う - TortoiseHg Advent Calendar 2012</title>
    <published>2012-12-15T16:00:00Z</published>
    <updated>2012-12-15T16:00:00Z</updated>
    <link rel="alternate" href="http://tcha.org/blog/2012/12/15/paranoid/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://connpass.com/event/1504/"&gt;TortoiseHg Advent Calendar 2012&lt;/a&gt;
の 15 日目です。今日はエクステンションのお話。&lt;/p&gt;

&lt;p&gt;普段コマンドラインの &lt;code&gt;hg&lt;/code&gt; に慣れていると、
TortoiseHg が何をしているか不安になりませんか?&lt;/p&gt;

&lt;p&gt;そんな方に朗報です。&lt;/p&gt;

&lt;h2&gt;paranoid エクステンション&lt;/h2&gt;

&lt;p&gt;ソース: &lt;a href="https://bitbucket.org/yuja/hgext-workarounds/src/tip/hgext/paranoid.py"&gt;https://bitbucket.org/yuja/hgext-workarounds/src/tip/hgext/paranoid.py&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def _runcommand(orig, lui, repo, cmd, fullargs, ui, options, d, cmdpats,
                cmdoptions):
    r = ui.promptchoice(_('about to execute: %s\nare you sure? (Y/n)')
                        % ('hg ' + subprocess.list2cmdline(fullargs)),
                        (_('&amp;amp;Yes'), _('&amp;amp;No')))
    if r == 1:
        raise util.Abort(_('by user request'))
    return orig(lui, repo, cmd, fullargs, ui, options, d, cmdpats, cmdoptions)

def uisetup(ui):
    extensions.wrapfunction(dispatch, 'runcommand', _runcommand)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;見てのとおりです。コマンド実行前に小うるさく確認を出してきよります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% hg update
about to execute: hg update
are you sure? (Y/n) n
中断: by user request
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CLI では無意味さ炸裂ですが、 GUI の場合はこんな風になります。&lt;/p&gt;

&lt;p&gt;&lt;img src="/blog/2012/assets/thg-paranoid.png" alt=""&gt;&lt;/p&gt;

&lt;h2&gt;まとめ&lt;/h2&gt;

&lt;p&gt;これで安心して TortoiseHg を使えますね!&lt;/p&gt;</content>
  </entry>
  <entry>
    <id>tag:tcha.org,2012-12-14:/blog/2012/12/14/thgemail/</id>
    <title type="html">パッチを投げよう - TortoiseHg Advent Calendar 2012</title>
    <published>2012-12-13T16:30:00Z</published>
    <updated>2012-12-13T16:30:00Z</updated>
    <link rel="alternate" href="http://tcha.org/blog/2012/12/14/thgemail/"/>
    <content type="html">&lt;p&gt;&lt;a href="http://connpass.com/event/1504/"&gt;TortoiseHg Advent Calendar 2012 - cointoss&lt;/a&gt;
の 14 日目は、
最も使用頻度が高いと思われる「メール送信」ダイアログについて書こうと思います。&lt;/p&gt;

&lt;h2&gt;メール送信ダイアログ&lt;/h2&gt;

&lt;p&gt;これです。パッチをメーリングリストへ投下します。&lt;/p&gt;

&lt;p&gt;&lt;img src="/blog/2012/assets/thg-email.png" alt=""&gt;&lt;/p&gt;

&lt;p&gt;え? 使ったこと無いって? モグリですね。&lt;/p&gt;

&lt;h2&gt;使い方&lt;/h2&gt;

&lt;p&gt;MQ で管理しているパッチを投げるには、コマンドラインにこうタイプしてください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% thg email qbase::
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;簡単ですね。リビジョンを指定せずに&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;% thg email
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;で起動すると、全てのリビジョンがリストアップされます。
送信したいリビジョンにチェックマークを入れて下さい。&lt;/p&gt;

&lt;p&gt;コミットが 1 万件程度であればパフォーマンスの問題は無いでしょう。&lt;/p&gt;

&lt;h2&gt;設定&lt;/h2&gt;

&lt;p&gt;メール送信サーバーの設定は &lt;code&gt;~/.hgrc&lt;/code&gt; (または &lt;code&gt;Mercurial.ini&lt;/code&gt;) に書きます。
(GUI のユーザー設定ダイアログでもかまいません)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[smtp]
host = smtp.gmail.com
port = 587
tls = True
username = &amp;lt;username&amp;gt;@gmail.com

[email]
bcc = &amp;lt;username&amp;gt;@gmail.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GMail を使っている場合は自分が送ったメールが配信されないため、
&lt;code&gt;bcc&lt;/code&gt; を入れておくと良いでしょう。&lt;/p&gt;

&lt;p&gt;それから、宛先アドレスを毎回書きたくないですよね?
宛先はリポジトリの &lt;code&gt;.hg/hgrc&lt;/code&gt; に書くのがオススメです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[email]
to = thg-dev@googlegroups.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;最後に&lt;/h2&gt;

&lt;p&gt;普段、コマンドラインの &lt;code&gt;hg email&lt;/code&gt; を使っている方も、試しに &lt;code&gt;thg email&lt;/code&gt;
を使ってみて下さい。
メールを出す前にプレビューできて便利ですよ!&lt;/p&gt;

&lt;p&gt;&lt;img src="/blog/2012/assets/thg-email-preview.png" alt=""&gt;&lt;/p&gt;</content>
  </entry>
</feed>
